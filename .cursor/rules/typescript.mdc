---
title: TypeScript Standards
version: 1.0.0
priority: high
description: TypeScript coding standards and best practices for nomoji.dev
---

# TypeScript Standards

This project uses TypeScript in strict mode with specific conventions.

## Configuration

### Compiler Options
- Target: ES2022
- Module: ES2022
- Strict mode: Enabled
- Isolated modules: True
- JSX: React JSX with Hono's JSX runtime (`jsxImportSource: "hono/jsx"`)

### Type Safety
Always use explicit types:
- Define return types for all functions
- Type all function parameters
- Use interfaces for object shapes
- Prefer `type` for unions, `interface` for objects
- Never use `any` without a documented reason

## Naming Conventions

### Variables and Functions
Use camelCase for variables and functions:
```typescript
const userId = "default";
function getUserConfig() { }
async function updateUserPreferences() { }
```

### Types and Interfaces
Use PascalCase for types and interfaces:
```typescript
interface NomojiConfig { }
type ContextConfig = { };
interface UserPreferences { }
```

### Constants
Use UPPER_CASE for true constants:
```typescript
const DEFAULT_CONFIG: NomojiConfig = { };
const PRESETS = { };
const API_VERSION = "1.0.0";
```

### Files
- Use lowercase with hyphens for utility files: `emoji-detector.ts`
- Use lowercase for single-word files: `cache.ts`, `storage.ts`
- Use PascalCase for React/JSX components: `HomePage.tsx`, `Layout.tsx`

## Code Organization

### Imports
Group and order imports:
1. External packages (Hono, etc.)
2. Internal types
3. Internal utilities
4. Internal components
5. Relative imports

```typescript
import { Hono } from "hono";
import type { Env, NomojiConfig } from "./types";
import { generateRules } from "./rules/generator";
import { HomePage } from "./views/home";
```

### Exports
- Prefer named exports over default exports for utilities
- Use default exports only for main entry points and components
- Export types alongside implementation when relevant

## Function Design

### Small and Focused
Keep functions small and single-purpose:
- Maximum 50 lines per function
- One responsibility per function
- Extract complex logic into separate functions

### Return Early
Use early returns to reduce nesting:
```typescript
async function getConfig(userId: string) {
  if (!userId) {
    return null;
  }
  
  const config = await fetch();
  if (!config) {
    return DEFAULT_CONFIG;
  }
  
  return config;
}
```

### Error Handling
Handle errors gracefully:
```typescript
try {
  const result = await riskyOperation();
  return result;
} catch (error) {
  logger.error("Operation failed", error as Error);
  throw new Error("Failed to complete operation");
}
```

## Type Patterns

### Use Discriminated Unions
For state or variant types:
```typescript
type ApiResponse<T = any> =
  | { success: true; data: T }
  | { success: false; error: string };
```

### Use Generics
For reusable functions:
```typescript
async function getOrCreate<T>(
  key: string,
  defaultValue: T
): Promise<T> {
  // Implementation
}
```

### Use Utility Types
Leverage TypeScript utility types:
```typescript
type PartialConfig = Partial<NomojiConfig>;
type ReadonlyConfig = Readonly<NomojiConfig>;
type ConfigKeys = keyof NomojiConfig;
```

## Async/Await

### Always Use Async/Await
Prefer async/await over raw promises:
```typescript
// Good
async function fetchData() {
  const response = await fetch(url);
  const data = await response.json();
  return data;
}

// Avoid
function fetchData() {
  return fetch(url)
    .then(response => response.json())
    .then(data => data);
}
```

### Parallel Execution
Use Promise.all for parallel operations:
```typescript
const [config, stats, metadata] = await Promise.all([
  getConfig(userId),
  getStats(userId),
  getMetadata(userId),
]);
```

## Comments and Documentation

### JSDoc for Public APIs
Document all exported functions:
```typescript
/**
 * Retrieves or creates user configuration
 * 
 * @param env - Cloudflare Workers environment bindings
 * @param userId - Unique user identifier
 * @returns User's nomoji configuration
 */
export async function getOrCreateUserConfig(
  env: Env,
  userId: string
): Promise<NomojiConfig> {
  // Implementation
}
```

### Inline Comments
Explain why, not what:
```typescript
// Use cache-control header to reduce API calls
c.header("Cache-Control", "public, max-age=3600");

// Avoid
// Set cache control header
c.header("Cache-Control", "public, max-age=3600");
```

## Best Practices

### Immutability
Prefer immutable operations:
```typescript
// Good
const updated = { ...config, version: "2.0.0" };

// Avoid
config.version = "2.0.0";
```

### Optional Chaining
Use optional chaining for nullable properties:
```typescript
const level = config?.metadata?.level ?? "info";
```

### Nullish Coalescing
Use ?? for default values:
```typescript
const timeout = config.timeout ?? 5000;
```

### Type Guards
Create type guards for runtime checks:
```typescript
function isNomojiConfig(value: unknown): value is NomojiConfig {
  return (
    typeof value === "object" &&
    value !== null &&
    "version" in value &&
    "contexts" in value
  );
}
```

## Anti-Patterns to Avoid

### Don't Use `any`
Avoid `any` unless absolutely necessary:
```typescript
// Bad
function process(data: any) { }

// Good
function process(data: unknown) {
  if (typeof data === "string") {
    // Handle string
  }
}
```

### Don't Ignore Errors
Always handle promise rejections:
```typescript
// Bad
await operation().catch(() => {});

// Good
await operation().catch((error) => {
  logger.error("Operation failed", error);
  throw error;
});
```

### Don't Use Non-Null Assertion
Avoid `!` operator, use type guards instead:
```typescript
// Bad
const config = getConfig()!;

// Good
const config = getConfig();
if (!config) {
  throw new Error("Config not found");
}
```

---

**Remember**: TypeScript's type system is your friend. Use it to catch errors at compile time, not runtime.
